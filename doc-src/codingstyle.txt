/**

@page codingstyle Photoropter coding style

@section code_org Code organisation

@subsection code_org_classes Classes and structs

<ul>
<li>The interface of polymorphic classes is extracted in form of a
(fully abstract) interface class, from which all the implementing classes
inherit.</li>
<li>Semantically different parts of a class's interface are
extracted into separate interface definitions.</li>
<li>Usually a header contains only a single class
definition. Exception: closely related interface definitons that form
a coherent unit.</li>
</ul>

@subsection code_org_misc Miscellaneous

<ul>
<li>Variables are declared one by one, each in a separate declaration
statement.</li>
<li>Functions that receive objects as parameters use references to the
interface base class wherever possible.</li>
<li>Enumerations are usually placed inside their own descriptive struct and
given a generic name like e.g. 'type'. This allows to refer to both
the enumeration as a whole as well as its values by using the
descriptive struct name, and thus avoids namespace pollution. </li>
<li>Every 'switch' statement contains a 'default:' label.</li>
<li>All public class interface elements and functions (especially those
that are expected to be used "from the outside") are documented using
Doxygen comments. Private classes members are generally also documented if
possible.</li>
</ul>

@section formatting Formatting

<ul>
<li>The source code is formatted according to the ANSI style.</li>
<li>Scope braces ('curly braces') are usually placed on separate lines.</li>
<li>Blocks are indented by 4 spaces. However, the corresponding scope braces
are not indented.</li>
<li>A sample configuration file for the astyle code formatter is provided.</li>
</ul>

@section naming Naming

@subsection naming_general General

<ul>
<li>All identifiers are plain English.</li>
<li>Identifiers are descriptive. Especially very short names
like i,k,l or x,y,z are used only for very shortlived variables (e.g.,
loop counters), and only if there cannot be any doubt about their
purpose.</li>
<li>Variables and typedefs are written in small letters, only using
[a-z0-9] as characters.</li>
<li>Variables and typedefs that contain more than one word are separated
using "_".</li>
<li>Typedefs are marked with a "_t" suffix.</li>
<li>Private variables in classes are marked with a single "_" suffix.</li>
</ul>

@subsection naming_classes Classes and structs

<ul>
<li>The same naming principles apply, with the following exceptions.</li>
<li>The first letter of a class name is capitalised. The following
letters remain lower-case.</li>
<li>Multiple words in a class name are separated by capitalisation
rather than "_" (i.e., 'camel casing' is used).</li>
<li>Interface definitions (i.e., fully abstract class definitions) are
marked by an initial letter "I". This is not considered the first
letter of the class name (i.e., the second point still applies).</li>
</ul>

@section langfeatures Language features

@subsection langfeatures_general General
<ul>
<li>The 'const' keyword is used proactively.</li>
<li>Namespaces are used wherever sensible. Semantically independent
parts of the code reside in separate namespaces.</li>
<li>The 'using' keyword is generally avoided, especially in the form
'using namespace [...]' at global scope.</li>
<li>Multiple inheritance is generally avoided. Exception: inheritance
of interface class definitions.</li>
<li>Visibility specifiers in classes and structs (e.g., 'public', 'private')
are repeated in front of every member declaration. Exception: public
members of structs are generally not specially marked (and non-public
members are usually shifted towards the end of the struct, if used at all).</li>
</ul>

@subsection langfeatures_classes Classes and structs

<ul>
<li>Structs are not considered classes (even if C++ does treat them like that).
The 'struct' keyword is only used for types that are semantically "not a class"
(see next point). Classes use the 'class' keyword exclusively.</li>
<li>A struct is only used for:<ul>
 <li>interoperability with C, or</li>
 <li>to hold constant, static and/or type information.</li>
 </ul></li>
<li>Structs have no 'surprising' side effects (like initialisation of buffers).</li>
<li>A struct is never used as base class.</li>
<li>Apart from constructors for member initialisation and 'const' functions
without side effects, a struct does not contain member functions.</li>
<li>Structs do not contain virtual members.</li>
<li>All classes usually declare a virtual destructor.</li>
<li>If there is a good reason to declare the destructor of a class non-virtual,
it is marked (and explained) in the documentation.</li>
<li>A class without virtual destructor is never used as base class.</li>
</ul>
*/
